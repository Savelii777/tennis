generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthSource {
  WEB
  TELEGRAM_BOT
  MOBILE_APP
}

enum StoryStatus {
  pending
  approved
  rejected
}

enum MediaType {
  image
  video
}

model Story {
  id               Int         @id @default(autoincrement())
  userId           Int
  telegramFileId   String
  telegramFilePath String?
  type             MediaType
  status           StoryStatus @default(pending)
  createdAt        DateTime    @default(now())
  publishedAt      DateTime?
  updatedAt        DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Country {
  id       Int    @id @default(autoincrement())
  name     String
  code     String @unique // ISO 3166-1 alpha-2
  flagUrl  String?
  cities   City[]
  users    User[]
  createdAt DateTime @default(now())
  
  @@index([code])
}


model City {
  id          Int     @id @default(autoincrement())
  name        String
  countryCode String
  country     Country @relation(fields: [countryCode], references: [code])
  population  Int
  lat         Float
  lng         Float
  timezone    String?
  users       User[]
  userSettings  UserSettings[]

  createdAt   DateTime @default(now())
  
  @@index([countryCode])
  @@index([population])
  @@index([name])
  @@unique([name, countryCode])
}

model Sport {
  id        Int    @id @default(autoincrement())
  title     String
  slug      String @unique
  emoji     String?
  users     User[]
  userSettings  UserSettings[]

  createdAt DateTime @default(now())
}


model UserSettings {
  id                      Int      @id @default(autoincrement())
  userId                  Int      @unique
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Основные настройки
  language                String   @default("ru") // 'ru' | 'en'
  cityId                  Int?
  city                    City?    @relation(fields: [cityId], references: [id])
  sportId                 Int?
  sport                   Sport?   @relation(fields: [sportId], references: [id])
  
  // Настройки уведомлений
  notificationsEnabled    Boolean  @default(true)
  notifyTelegram          Boolean  @default(true)
  notifyEmail             Boolean  @default(false)
  matchReminderTime       String   @default("1h") // '1h' | '1d' | 'off'
  notifyMatchResults      Boolean  @default(true)
  notifyTournamentResults Boolean  @default(true)
  
  // Приватность и безопасность
  showProfilePublicly     Boolean  @default(true)
  showRatingPublicly      Boolean  @default(true)
  allowMatchInvites       Boolean  @default(true)
  requireMatchConfirm     Boolean  @default(false)
  
  // Предпочтения по соперникам
  preferredGender         String?  // 'male' | 'female' | 'any'
  preferredAgeMin         Int?
  preferredAgeMax         Int?
  preferredLevelMin       Float?   // NTRP рейтинг
  preferredLevelMax       Float?
  
  // Дополнительные настройки
  theme                   String   @default("light") // 'light' | 'dark' | 'auto'
  timezone                String   @default("Europe/Moscow")
  
  // Telegram специфичные
  telegramChatId          String?
  
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  
  @@index([userId])
  @@index([language])
  @@index([notificationsEnabled])
}

model User {
  id            Int      @id @default(autoincrement())
  telegramId    String   @unique
  username      String   @unique
  firstName     String
  lastName      String?
  isVerified    Boolean  @default(false)
  role          Role     @default(USER)
  countryCode String? 
  country     Country? @relation(fields: [countryCode], references: [code])
  cityId      Int?
  city        City?    @relation(fields: [cityId], references: [id])
  sportId     Int?
  sport       Sport?   @relation(fields: [sportId], references: [id])
  profile       UserProfile?
  matches       Match[]  @relation("PlayerMatches")
  createdMatches Match[] @relation("CreatorMatches")
  createdTrainings Training[] @relation("TrainingCreator")
  createdTrainingSessions TrainingSession[] @relation("TrainingSessionCreator")
  createdTournaments Tournament[] @relation("TournamentOrganizer")
  sentInvites Invite[] @relation("InviteSender")
  receivedInvites Invite[] @relation("InviteReceiver") 
  tournaments    Tournament[]
  createdRequests     GameRequest[]      @relation()
  requestParticipations GameRequest[]  @relation("RequestParticipants")
  requestResponses    RequestResponse[]
  trainingSessionParticipations TrainingSession[] @relation("TrainingParticipants")
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())
  authSource    AuthSource   @default(WEB)
  lastLogin     DateTime?
  ballsBalance  Int          @default(0)
  casesOpened   Int          @default(0)
  telegramChatId BigInt?      // Для хранения chat_id пользователя
  caseOpenings    CaseOpening[]
  caseWinnings    CaseWinning[]
  // Новые обратные связи
  ballTransactions BallTransaction[]
  stories         Story[]

  referralCode      String?  @unique // Уникальный код пользователя для приглашений
  referredBy        Int?     // ID пользователя, который пригласил
  referrer          User?    @relation("UserReferrals", fields: [referredBy], references: [id])
  referrals         User[]   @relation("UserReferrals") // Список приглашенных пользователей
  referralStats     ReferralStats?
  referrerActivities  ReferralActivity[] @relation("ReferrerActivity")
  invitedActivities   ReferralActivity[] @relation("InvitedActivity")

  notifications Notification[]
  achievements UserAchievement[] @relation("UserAchievements")

  rating        PlayerRating?
  ratingHistory RatingHistory[]
  opponentHistory RatingHistory[] @relation("OpponentHistory")

  settings      UserSettings?

}


// Заменяем модели PlayerRating и RatingHistory на правильные версии

model PlayerRating {
  id            Int      @id @default(autoincrement())
  userId        Int      @unique
  user          User     @relation(fields: [userId], references: [id])
  
  // S-Rating (Skill Rating)
  skillRating   Float    @default(4.0)  // NTRP рейтинг (2.0 - 7.0)
  skillPoints   Int      @default(1400) // Эло-подобные очки
  
  // P-Rating (Points Rating)
  pointsRating  Int      @default(1000) // Очки активности
  
  // Статистика
  wins          Int      @default(0)
  losses        Int      @default(0)
  
  lastUpdated   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([skillPoints])
  @@index([pointsRating])
}

model RatingHistory {
  id                   Int      @id @default(autoincrement())
  userId               Int
  user                 User     @relation(fields: [userId], references: [id])
  
  matchId              Int?
  match                Match?   @relation(fields: [matchId], references: [id])
  
  seasonId             Int?
  season               RatingSeason? @relation(fields: [seasonId], references: [id])
  
  // Рейтинг до и после
  skillPointsBefore    Int
  skillPointsAfter     Int
  pointsRatingBefore   Int
  pointsRatingAfter    Int
  
  // Детали матча
  isWin                Boolean
  opponentId           Int?
  opponent             User?    @relation("OpponentHistory", fields: [opponentId], references: [id])
  opponentSkillPoints  Int?
  
  // Начисленные очки
  pointsEarned         Int
  reason               String   // "match_win", "tournament_participation", etc.
  
  createdAt            DateTime @default(now())
  
  @@index([userId])
  @@index([matchId])
  @@index([seasonId])
}

model RatingSeason {
  id          Int      @id @default(autoincrement())
  title       String
  startDate   DateTime
  endDate     DateTime
  isCurrent   Boolean  @default(false)
  description String?
  
  // История рейтингов в этом сезоне
  history     RatingHistory[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([isCurrent])
  @@index([startDate, endDate])
}


model UserAchievement {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation("UserAchievements", fields: [userId], references: [id])
  code        String   // "first_win", "10_matches", etc.
  awardedAt   DateTime @default(now())
  
  // Дополнительные данные достижения
  metadata    Json?    // Дополнительная информация о достижении
  
  createdAt   DateTime @default(now())
  
  @@unique([userId, code]) // Пользователь не может получить одно достижение дважды
  @@index([userId])
  @@index([code])
  @@index([awardedAt])
}

model ReferralStats {
  id                Int      @id @default(autoincrement())
  userId            Int      @unique
  user              User     @relation(fields: [userId], references: [id])
  
  // Статистика приглашений
  totalInvited      Int      @default(0) // Всего приглашено
  activeInvited     Int      @default(0) // Активных приглашенных (сыграли хотя бы 1 матч)
  registeredToday   Int      @default(0) // Зарегистрировались сегодня
  registeredThisWeek Int     @default(0) // Зарегистрировались на этой неделе
  registeredThisMonth Int    @default(0) // Зарегистрировались в этом месяце
  
  // Достижения и награды
  achievementsEarned String[] // Полученные достижения за рефералов
  bonusPointsEarned  Int      @default(0) // Бонусные очки за рефералов
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId])
}
model ReferralActivity {
  id              Int      @id @default(autoincrement())
  referrerId      Int      // Кто пригласил
  referrer        User     @relation("ReferrerActivity", fields: [referrerId], references: [id])
  invitedUserId   Int      // Кого пригласили
  invitedUser     User     @relation("InvitedActivity", fields: [invitedUserId], references: [id])
  
  // Активность приглашенного
  registeredAt    DateTime
  firstMatchAt    DateTime? // Когда сыграл первый матч
  isActive        Boolean  @default(false) // Считается активным если сыграл хотя бы 1 матч
  
  // Дополнительная информация
  inviteSource    String?  // telegram, whatsapp, direct, etc.
  ipAddress       String?  // IP при регистрации (для аналитики)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([referrerId])
  @@index([invitedUserId])
  @@index([registeredAt])
}

model BallTransaction {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  amount        Int      // Положительное для пополнения, отрицательное для списания
  type          BallTransactionType
  reason        String   // Описание операции
  balanceAfter  Int      // Баланс после операции
  createdAt     DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
}
enum BallTransactionType {
  EARNED   // Заработано
  SPENT    // Потрачено
  BONUS    // Бонус
  REFUND   // Возврат
}
model Case {
  id            Int      @id @default(autoincrement())
  name          String
  description   String
  priceBalls    Int      // Цена в теннисных мячах
  image         String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Связи
  items         CaseItem[]
  openings      CaseOpening[]
  winnings      CaseWinning[]
}

model CaseItem {
  id            Int      @id @default(autoincrement())
  caseId        Int
  case          Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  name          String   // "50 мячей", "Футболка", "Сертификат Ozon"
  type          CaseItemType // virtual, physical, action
  payload       Json     // {balls: 50} или {sku: "tshirt_l"}
  dropChance    Float    // 0.01–1.0 (1% - 100%)
  imageUrl      String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Связи
  winnings      CaseWinning[]
  
  @@index([caseId])
  @@index([isActive])
}

model CaseOpening {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  caseId        Int
  case          Case     @relation(fields: [caseId], references: [id])
  ballsSpent    Int      // Сколько мячей потратил
  createdAt     DateTime @default(now())
  
  // Связь с выигрышем
  winning       CaseWinning?
}
model CaseWinning {
  id              Int         @id @default(autoincrement())
  openingId       Int         @unique
  opening         CaseOpening @relation(fields: [openingId], references: [id])
  userId          Int
  user            User        @relation(fields: [userId], references: [id])
  caseId          Int
  case            Case        @relation(fields: [caseId], references: [id])
  itemId          Int
  item            CaseItem    @relation(fields: [itemId], references: [id])
  
  // Статус получения приза
  isProcessed     Boolean     @default(false)
  processedAt     DateTime?
  notes           String?     // Примечания для физических призов
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([userId])
  @@index([caseId])
  @@index([itemId])
  @@index([isProcessed])
}
enum CaseItemType {
  VIRTUAL   // виртуальные призы (мячи, бейджи)
  PHYSICAL  // физические призы (футболки, сертификаты)
  ACTION    // особые действия (скидки, доступы)
}
model Match {
  id            Int      @id @default(autoincrement())
  creator       User     @relation("CreatorMatches", fields: [creatorId], references: [id])
  creatorId     Int
  player1       User?    @relation("PlayerMatches", fields: [player1Id], references: [id])
  player1Id     Int?
  player2Id     Int?
  optionalId    Int?
  type          MatchType
  state         MatchState
  score         String?
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  ratingHistory RatingHistory[]

}

model Training {
  id            Int      @id @default(autoincrement())
  creator       User     @relation("TrainingCreator", fields: [creatorId], references: [id])
  creatorId     Int
  location      String
  time          DateTime
  participantLimit Int
  description   String?
  state         TrainingState
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Tournament {
  id            Int      @id @default(autoincrement())
  title         String
  description   String?
  type          TournamentType
  status        String
  creator       User     @relation("TournamentOrganizer", fields: [creatorId], references: [id])
  creatorId     Int
  startDate     DateTime
  endDate       DateTime
  formatDetails Json?
  minPlayers    Int
  maxPlayers    Int
  currentPlayers Int
  isRanked      Boolean
  locationId    Int?
  locationName  String?
  players       User[]
  matches       TournamentMatch[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model TournamentMatch {
  id               Int       @id @default(autoincrement())
  tournament       Tournament @relation(fields: [tournamentId], references: [id])
  tournamentId     Int
  round            Int?
  group            String?
  playerAId        Int
  playerBId        Int?
  score            String?
  winnerId         Int?
  status           String
  court            String?
  scheduledAt      DateTime?
  confirmedBy      Int[]
  isThirdPlaceMatch Boolean @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model Invite {
  id            Int      @id @default(autoincrement())
  match         Match?   @relation(fields: [matchId], references: [id])
  matchId       Int?
  training      Training? @relation(fields: [trainingId], references: [id])
  trainingId    Int?
  sender        User     @relation("InviteSender", fields: [senderId], references: [id])
  senderId      Int
  receiver      User     @relation("InviteReceiver", fields: [receiverId], references: [id])
  receiverId    Int
  status        InviteStatus
  createdAt     DateTime @default(now())
}


model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  type      NotificationType
  message   String
  payload   Json?    // Дополнительные данные для фронтенда
  isRead    Boolean  @default(false)
  sentAt    DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}
enum NotificationType {
  MATCH_SCHEDULED
  MATCH_REMINDER
  MATCH_CANCELLED
  TOURNAMENT_RESULT
  NEW_INVITE
  INVITE_ACCEPTED
  INVITE_DECLINED
  TRAINING_REMINDER
  SYSTEM_MESSAGE
  REFERRAL_BONUS
  CASE_OPENED
}
model UserProfile {
  id              Int      @id @default(autoincrement())
  user            User     @relation(fields: [userId], references: [id])
  userId          Int      @unique
  avatarUrl       String?
  city            String?
  countryCode     String?
  ntrpRating      Float?
  ratingPoints    Int      @default(0)
  matchesPlayed   Int      @default(0)
  matchWins       Int      @default(0)
  matchLosses     Int      @default(0)
  tournamentsPlayed Int    @default(0)
  tournamentsWon   Int     @default(0)
  lastActivity    DateTime?
  achievements    Json?
  isPublicProfile Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

    // ШАГ 1: Основные данные игрока
  preferredCourt      String?       // часто используемый корт
  dominantHand        String?       @default("RIGHT") // RIGHT, LEFT
  preferredPlayTime   String[]      // ['MORNING', 'DAY', 'EVENING', 'NIGHT']
  playsInTournaments  Boolean       @default(false)   // играет ли в турнирах
  weeklyPlayFrequency String?       // ONE, TWO_THREE, FOUR_PLUS
  
  // ШАГ 2: Стиль игры и уровень
  backhandType        String?       // ONE_HANDED, TWO_HANDED
  preferredSurface    String?       // HARD, CLAY, GRASS, CARPET
  playingStyle        String?       // UNIVERSAL, DEFENSIVE, AGGRESSIVE, NET_PLAYER, BASIC
  favoriteShot        String?       // SERVE, FOREHAND, BACKHAND, VOLLEY, SMASH
  racket              String?       // модель ракетки
  opponentPreference  String?       // ANY, MEN, WOMEN, SAME_LEVEL, STRONGER, WEAKER
  
  // Для рейтинга
  initialRatingPoints Int?          // начальные рейтинговые очки
  selfAssessedLevel   String?       // BEGINNER, AMATEUR, CONFIDENT, TOURNAMENT, SEMI_PRO
  profileStepOneCompleted Boolean @default(false)
  profileStepTwoCompleted Boolean @default(false)
}



model GameRequest {
  id               Int          @id @default(autoincrement())
  type             String       // Or use enum RequestType if defined
  title            String
  description      String?
  creatorId        Int
  creator          User         @relation(fields: [creatorId], references: [id])
  locationName     String?
  maxPlayers       Int
  currentPlayers   Int          @default(1)
  gameMode         String       // Or use enum MatchType
  dateTime         DateTime
  paymentType      String       // Or use enum PaymentType
  ratingType       String       // Or use enum RatingType  
  formatInfo       Json?
  status           String       @default("OPEN")
  participants     User[]       @relation("RequestParticipants")
  responses        RequestResponse[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

model RequestResponse {
  id              Int           @id @default(autoincrement())
  requestId       Int
  request         GameRequest   @relation(fields: [requestId], references: [id])
  userId          Int
  user            User          @relation(fields: [userId], references: [id])
  status          String        @default("PENDING")
  message         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([requestId, userId])
}

model TrainingSession {
  id               Int           @id @default(autoincrement())
  title            String
  description      String?
  creatorId        Int
  creator          User          @relation("TrainingSessionCreator", fields: [creatorId], references: [id])
  locationName     String?
  courtSurface     CourtSurface? @default(HARD)
  minLevel         Float?        // Минимальный NTRP уровень
  maxLevel         Float?        // Максимальный NTRP уровень
  maxSlots         Int
  currentSlots     Int           @default(1)
  paymentType      PaymentType   @default(DIVIDED)
  pricePerPerson   Float?
  dateTime         DateTime
  endTime          DateTime
  status           TrainingState @default(OPEN)
  trainingType     TrainingType  @default(WITHOUT_COACH)
  participants     User[]        @relation("TrainingParticipants")
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

enum Role {
  USER
  ORGANIZER
  ADMIN
}

enum MatchType {
  ONE_ON_ONE
  DOUBLES
}

enum MatchState {
  DRAFT
  PENDING
  CONFIRMED
  FINISHED
  CANCELLED
}

enum TrainingState {
  OPEN
  FULL
  CANCELLED
  DONE
}

enum TournamentType {
  SINGLE_ELIMINATION
  GROUPS_PLAYOFF
  LEAGUE
  BLITZ
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum SportType {
  TENNIS
  PADEL
}

enum RequestType {
  SINGLE_GAME
  TOURNAMENT
  TRAINING
}

enum RequestStatus {
  OPEN
  CLOSED
  CANCELLED
  DONE
}

enum ResponseStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum PaymentType {
  FREE
  HOST_PAYS
  LOSER_PAYS
  DIVIDED
  FIXED_PRICE
}

enum RatingType {
  RATED
  UNRATED
}

enum TrainingType {
  WITH_COACH
  WITHOUT_COACH
  TIEBREAK
  SPARRING
  TECHNIQUE
}

enum CourtSurface {
  HARD
  CLAY
  GRASS
  CARPET
}