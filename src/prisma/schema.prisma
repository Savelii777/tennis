generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthSource {
  WEB
  TELEGRAM_BOT
  MOBILE_APP
}

enum StoryStatus {
  pending
  approved
  rejected
}

enum MediaType {
  image
  video
}


model DirectMessage {
  id            Int      @id @default(autoincrement())
  senderId      Int
  recipientId   Int
  message       String
  isRead        Boolean  @default(false)
  createdAt     DateTime @default(now())
  
  sender        User     @relation("SentMessages", fields: [senderId], references: [id])
  recipient     User     @relation("ReceivedMessages", fields: [recipientId], references: [id])
  
  @@index([senderId])
  @@index([recipientId])
}

model Story {
  id               Int         @id @default(autoincrement())
  userId           Int
  telegramFileId   String
  telegramFilePath String?
  type             MediaType
  status           StoryStatus @default(pending)
  createdAt        DateTime    @default(now())
  publishedAt      DateTime?
  updatedAt        DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Country {
  id       Int    @id @default(autoincrement())
  name     String
  code     String @unique // ISO 3166-1 alpha-2
  flagUrl  String?
  cities   City[]
  users    User[]
  createdAt DateTime @default(now())
  
  @@index([code])
}

model City {
  id          Int     @id @default(autoincrement())
  name        String
  countryCode String
  country     Country @relation(fields: [countryCode], references: [code])
  population  Int
  lat         Float
  lng         Float
  timezone    String?
  users       User[]
  userSettings  UserSettings[]

  createdAt   DateTime @default(now())
  
  @@index([countryCode])
  @@index([population])
  @@index([name])
  @@unique([name, countryCode])
}



model Sport {
  id        Int    @id @default(autoincrement())
  title     String
  slug      String @unique
  emoji     String?
  icon      String? // Добавляем поле для хранения идентификатора иконки
  users     User[]
  userSettings  UserSettings[]

  createdAt DateTime @default(now())
}

model UserSettings {
  id                      Int      @id @default(autoincrement())
  userId                  Int      @unique
  user                    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Основные настройки
  language                String   @default("ru") // 'ru' | 'en'
  cityId                  Int?
  city                    City?    @relation(fields: [cityId], references: [id])
  sportId                 Int?
  sport                   Sport?   @relation(fields: [sportId], references: [id])
  
  // Настройки уведомлений
  notificationsEnabled    Boolean  @default(true)
  notifyTelegram          Boolean  @default(true)
  notifyEmail             Boolean  @default(false)
  matchReminderTime       String   @default("1h") // '1h' | '1d' | 'off'
  notifyMatchResults      Boolean  @default(true)
  notifyTournamentResults Boolean  @default(true)
  
  // Приватность и безопасность
  showProfilePublicly     Boolean  @default(true)
  showRatingPublicly      Boolean  @default(true)
  allowMatchInvites       Boolean  @default(true)
  requireMatchConfirm     Boolean  @default(false)
  
  // Предпочтения по соперникам
  preferredGender         String?  // 'male' | 'female' | 'any'
  preferredAgeMin         Int?
  preferredAgeMax         Int?
  preferredLevelMin       Float?   // NTRP рейтинг
  preferredLevelMax       Float?
  
  // Дополнительные настройки
  theme                   String   @default("light") // 'light' | 'dark' | 'auto'
  timezone                String   @default("Europe/Moscow")
  
  // Telegram специфичные
  telegramChatId          String?
  
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  
  @@index([userId])
  @@index([language])
  @@index([notificationsEnabled])

  allowDirectMessages Boolean @default(true)

}

model User {
  id            Int      @id @default(autoincrement())
  telegramId    String   @unique
  username      String   @unique
  firstName     String
  lastName      String?
  isVerified    Boolean  @default(false)
  role          Role     @default(USER)
  countryCode   String?
  country       Country? @relation(fields: [countryCode], references: [code])
  cityId        Int?
  city          City?    @relation(fields: [cityId], references: [id])
  sportId       Int?
  sport         Sport?   @relation(fields: [sportId], references: [id])
  
  // Профиль и связи
  profile       UserProfile?
  
  // Матчи - исправленные связи
  createdMatches Match[] @relation("CreatorMatches")
  player1Matches Match[] @relation("Player1Matches")
  player2Matches Match[] @relation("Player2Matches")
  wonMatches     Match[] @relation("MatchWinner")
  
  // Турнирные матчи
  tournamentMatchesA TournamentMatch[] @relation("TournamentPlayerA")
  tournamentMatchesB TournamentMatch[] @relation("TournamentPlayerB")
  tournamentMatchesWon TournamentMatch[] @relation("TournamentWinner")
  
  // Тренировки и турниры
  createdTrainings Training[] @relation("TrainingCreator")
  createdTrainingSessions TrainingSession[] @relation("TrainingSessionCreator")
  createdTournaments Tournament[] @relation("TournamentOrganizer")
  
  // Приглашения
  sentInvites Invite[] @relation("InviteSender")
  receivedInvites Invite[] @relation("InviteReceiver") 
  
  // Запросы и участия
  tournaments    Tournament[]
  createdRequests GameRequest[]
  requestParticipations GameRequest[] @relation("RequestParticipants")
  requestResponses RequestResponse[]
  trainingSessionParticipations TrainingSession[] @relation("TrainingParticipants")
  
  // Общая информация
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())
  authSource    AuthSource @default(WEB)
  lastLogin     DateTime?
  ballsBalance  Int      @default(0)
  casesOpened   Int      @default(0)
  telegramChatId BigInt?  // Для хранения chat_id пользователя
  
  // Транзакции и открытия кейсов
  caseOpenings    CaseOpening[]
  caseWinnings    CaseWinning[]
  ballTransactions BallTransaction[]
  stories         Story[]

  // Реферальная система
  referralCode      String?  @unique
  referredBy        Int?
  referrer          User?    @relation("UserReferrals", fields: [referredBy], references: [id])
  referrals         User[]   @relation("UserReferrals")
  referralStats     ReferralStats?
  referrerActivities ReferralActivity[] @relation("ReferrerActivity")
  invitedActivities ReferralActivity[] @relation("InvitedActivity")

  // Уведомления и достижения
  notifications Notification[]
  achievements UserAchievement[] @relation("UserAchievements")

  // Рейтинг
  rating        PlayerRating?
  ratingHistory RatingHistory[]
  opponentHistory RatingHistory[] @relation("OpponentHistory")
  
  // Настройки
  settings      UserSettings?

  sentMessages     DirectMessage[] @relation("SentMessages")
  receivedMessages DirectMessage[] @relation("ReceivedMessages")
}

// Модели рейтинга
model PlayerRating {
  id            Int      @id @default(autoincrement())
  userId        Int      @unique
  user          User     @relation(fields: [userId], references: [id])
  
  // S-Rating (Skill Rating)
  skillRating   Float    @default(4.0)  // NTRP рейтинг (2.0 - 7.0)
  skillPoints   Int      @default(1400) // Эло-подобные очки
  
  // P-Rating (Points Rating)
  pointsRating  Int      @default(1000) // Очки активности
  
  // Статистика
  wins          Int      @default(0)
  losses        Int      @default(0)
  
  lastUpdated   DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([skillPoints])
  @@index([pointsRating])
}

model RatingHistory {
  id                   Int      @id @default(autoincrement())
  userId               Int
  user                 User     @relation(fields: [userId], references: [id])
  
  matchId              Int?
  match                Match?   @relation(fields: [matchId], references: [id])
  
  seasonId             Int?
  season               RatingSeason? @relation(fields: [seasonId], references: [id])
  
  // Рейтинг до и после
  skillPointsBefore    Int
  skillPointsAfter     Int
  pointsRatingBefore   Int
  pointsRatingAfter    Int
  
  // Детали матча
  isWin                Boolean
  opponentId           Int?
  opponent             User?    @relation("OpponentHistory", fields: [opponentId], references: [id])
  opponentSkillPoints  Int?
  
  // Начисленные очки
  pointsEarned         Int
  reason               String   // "match_win", "tournament_participation", etc.
  
  createdAt            DateTime @default(now())
  
  @@index([userId])
  @@index([matchId])
  @@index([seasonId])
}

model RatingSeason {
  id          Int      @id @default(autoincrement())
  title       String
  startDate   DateTime
  endDate     DateTime
  isCurrent   Boolean  @default(false)
  description String?
  
  // История рейтингов в этом сезоне
  history     RatingHistory[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([isCurrent])
  @@index([startDate, endDate])
}

model UserAchievement {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation("UserAchievements", fields: [userId], references: [id])
  code        String   // "first_win", "10_matches", etc.
  awardedAt   DateTime @default(now())
  
  // Дополнительные данные достижения
  metadata    Json?    // Дополнительная информация о достижении
  
  createdAt   DateTime @default(now())
  
  @@unique([userId, code]) // Пользователь не может получить одно достижение дважды
  @@index([userId])
  @@index([code])
  @@index([awardedAt])
}

model ReferralStats {
  id                Int      @id @default(autoincrement())
  userId            Int      @unique
  user              User     @relation(fields: [userId], references: [id])
  
  // Статистика приглашений
  totalInvited      Int      @default(0)
  activeInvited     Int      @default(0)
  registeredToday   Int      @default(0)
  registeredThisWeek Int     @default(0)
  registeredThisMonth Int    @default(0)
  
  // Достижения и награды
  achievementsEarned String[] // Полученные достижения за рефералов
  bonusPointsEarned  Int      @default(0) // Бонусные очки за рефералов
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([userId])
}

model ReferralActivity {
  id              Int      @id @default(autoincrement())
  referrerId      Int      // Кто пригласил
  referrer        User     @relation("ReferrerActivity", fields: [referrerId], references: [id])
  invitedUserId   Int      // Кого пригласили
  invitedUser     User     @relation("InvitedActivity", fields: [invitedUserId], references: [id])
  
  // Активность приглашенного
  registeredAt    DateTime
  firstMatchAt    DateTime?
  isActive        Boolean  @default(false)
  
  // Дополнительная информация
  inviteSource    String?  // telegram, whatsapp, direct, etc.
  ipAddress       String?  // IP при регистрации
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([referrerId])
  @@index([invitedUserId])
  @@index([registeredAt])
}

model BallTransaction {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  amount        Int
  type          BallTransactionType
  reason        String
  balanceAfter  Int
  createdAt     DateTime @default(now())
  
  @@index([userId])
  @@index([createdAt])
}

enum BallTransactionType {
  EARNED
  SPENT
  BONUS
  REFUND
}

model Case {
  id            Int      @id @default(autoincrement())
  name          String
  description   String
  priceBalls    Int
  image         String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  items         CaseItem[]
  openings      CaseOpening[]
  winnings      CaseWinning[]
}

model CaseItem {
  id            Int      @id @default(autoincrement())
  caseId        Int
  case          Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  name          String
  type          CaseItemType
  payload       Json
  dropChance    Float
  imageUrl      String?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  winnings      CaseWinning[]
  
  @@index([caseId])
  @@index([isActive])
}

model CaseOpening {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  caseId        Int
  case          Case     @relation(fields: [caseId], references: [id])
  ballsSpent    Int
  createdAt     DateTime @default(now())
  
  winning       CaseWinning?
}

model CaseWinning {
  id              Int         @id @default(autoincrement())
  openingId       Int         @unique
  opening         CaseOpening @relation(fields: [openingId], references: [id])
  userId          Int
  user            User        @relation(fields: [userId], references: [id])
  caseId          Int
  case            Case        @relation(fields: [caseId], references: [id])
  itemId          Int
  item            CaseItem    @relation(fields: [itemId], references: [id])
  
  isProcessed     Boolean     @default(false)
  processedAt     DateTime?
  notes           String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([userId])
  @@index([caseId])
  @@index([itemId])
  @@index([isProcessed])
}

enum CaseItemType {
  VIRTUAL
  PHYSICAL
  ACTION
}

model Match {
  id            Int      @id @default(autoincrement())
  creatorId     Int
  player1Id     Int?
  player2Id     Int?
  optionalId    Int?
  winnerId      Int?     // Добавлено поле для хранения ID победителя
  type          MatchType
  state         MatchState
  score         String?
  matchDate     DateTime @default(now()) // Добавлено для хранения даты матча
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  ratingHistory RatingHistory[]
  
  // Исправленные связи
  creator   User    @relation("CreatorMatches", fields: [creatorId], references: [id])
  player1   User?   @relation("Player1Matches", fields: [player1Id], references: [id])
  player2   User?   @relation("Player2Matches", fields: [player2Id], references: [id])
  winner    User?   @relation("MatchWinner", fields: [winnerId], references: [id])
}

model Training {
  id            Int      @id @default(autoincrement())
  creator       User     @relation("TrainingCreator", fields: [creatorId], references: [id])
  creatorId     Int
  location      String
  time          DateTime
  participantLimit Int
  description   String?
  state         TrainingState
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Tournament {
  id            Int      @id @default(autoincrement())
  title         String
  description   String?
  type          TournamentType
  status        String
  creator       User     @relation("TournamentOrganizer", fields: [creatorId], references: [id])
  creatorId     Int
  startDate     DateTime
  endDate       DateTime
  formatDetails Json?
  minPlayers    Int
  maxPlayers    Int
  currentPlayers Int
  isRanked      Boolean
  locationId    Int?
  locationName  String?
  players       User[]
  matches       TournamentMatch[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model TournamentMatch {
  id               Int       @id @default(autoincrement())
  tournament       Tournament @relation(fields: [tournamentId], references: [id])
  tournamentId     Int
  round            Int?
  group            String?
  playerAId        Int
  playerBId        Int?
  winnerId         Int?
  score            String?
  status           String
  court            String?
  scheduledAt      DateTime?
  confirmedBy      Int[]
  isThirdPlaceMatch Boolean @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  // Добавленные связи 
  playerA          User     @relation("TournamentPlayerA", fields: [playerAId], references: [id])
  playerB          User?    @relation("TournamentPlayerB", fields: [playerBId], references: [id])
  winner           User?    @relation("TournamentWinner", fields: [winnerId], references: [id])
}

model Invite {
  id            Int      @id @default(autoincrement())
  match         Match?   @relation(fields: [matchId], references: [id])
  matchId       Int?
  training      Training? @relation(fields: [trainingId], references: [id])
  trainingId    Int?
  sender        User     @relation("InviteSender", fields: [senderId], references: [id])
  senderId      Int
  receiver      User     @relation("InviteReceiver", fields: [receiverId], references: [id])
  receiverId    Int
  status        InviteStatus
  createdAt     DateTime @default(now())
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  type      NotificationType
  message   String   // Единое поле для текста уведомления
  data      Json?    // Переименовано из payload для согласованности
  isRead    Boolean  @default(false)
  sentAt    DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}

// Добавленная модель для телеграм-бота
model UserState {
  id        Int      @id @default(autoincrement())
  userId    String   @unique  // telegram_id пользователя
  step      ProfileStep // Текущий шаг в enum формате
  data      Json     // Хранение данных состояния
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([userId])
}

enum ProfileStep {
  AWAITING_CITY
  AWAITING_COURT
  AWAITING_HAND
  AWAITING_FREQUENCY
  AWAITING_TOURNAMENTS
  AWAITING_LEVEL
  COMPLETE
}

enum NotificationType {
  MATCH_SCHEDULED
  MATCH_REMINDER
  MATCH_CANCELLED
  TOURNAMENT_RESULT
  NEW_INVITE
  INVITE_ACCEPTED
  INVITE_DECLINED
  TRAINING_REMINDER
  SYSTEM_MESSAGE
  REFERRAL_BONUS
  CASE_OPENED
}

model UserProfile {
  id              Int      @id @default(autoincrement())
  user            User     @relation(fields: [userId], references: [id])
  userId          Int      @unique
  avatarUrl       String?
  city            String?
  countryCode     String?
  ntrpRating      Float?
  ratingPoints    Int      @default(0)
  matchesPlayed   Int      @default(0)
  matchWins       Int      @default(0)
  matchLosses     Int      @default(0)
  tournamentsPlayed Int    @default(0)
  tournamentsWon   Int     @default(0)
  lastActivity    DateTime?
  achievements    Json?
  isPublicProfile Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // ШАГ 1: Основные данные игрока
  preferredCourt      String?       // часто используемый корт
  dominantHand        String?       @default("RIGHT") // RIGHT, LEFT
  preferredPlayTime   String[]      // ['MORNING', 'DAY', 'EVENING', 'NIGHT']
  playsInTournaments  Boolean       @default(false)   // играет ли в турнирах
  weeklyPlayFrequency String?       // ONE, TWO_THREE, FOUR_PLUS
  
  // ШАГ 2: Стиль игры и уровень
  backhandType        String?       // ONE_HANDED, TWO_HANDED
  preferredSurface    String?       // HARD, CLAY, GRASS, CARPET
  playingStyle        String?       // UNIVERSAL, DEFENSIVE, AGGRESSIVE, NET_PLAYER, BASIC
  favoriteShot        String?       // SERVE, FOREHAND, BACKHAND, VOLLEY, SMASH
  racket              String?       // модель ракетки
  opponentPreference  String?       // ANY, MEN, WOMEN, SAME_LEVEL, STRONGER, WEAKER
  
  // Для рейтинга
  initialRatingPoints Int?          // начальные рейтинговые очки
  selfAssessedLevel   String?       // BEGINNER, AMATEUR, CONFIDENT, TOURNAMENT, SEMI_PRO
  profileStepOneCompleted Boolean @default(false)
  profileStepTwoCompleted Boolean @default(false)
}

model GameRequest {
  id               Int          @id @default(autoincrement())
  type             String
  title            String
  description      String?
  creatorId        Int
  creator          User         @relation(fields: [creatorId], references: [id])
  locationName     String?
  maxPlayers       Int
  currentPlayers   Int          @default(1)
  gameMode         String
  dateTime         DateTime
  paymentType      String
  ratingType       String 
  formatInfo       Json?
  status           String       @default("OPEN")
  participants     User[]       @relation("RequestParticipants")
  responses        RequestResponse[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

model RequestResponse {
  id              Int           @id @default(autoincrement())
  requestId       Int
  request         GameRequest   @relation(fields: [requestId], references: [id])
  userId          Int
  user            User          @relation(fields: [userId], references: [id])
  status          String        @default("PENDING")
  message         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([requestId, userId])
}

model TrainingSession {
  id               Int           @id @default(autoincrement())
  title            String
  description      String?
  creatorId        Int
  creator          User          @relation("TrainingSessionCreator", fields: [creatorId], references: [id])
  locationName     String?
  courtSurface     CourtSurface? @default(HARD)
  minLevel         Float?
  maxLevel         Float?
  maxSlots         Int
  currentSlots     Int           @default(1)
  paymentType      PaymentType   @default(DIVIDED)
  pricePerPerson   Float?
  dateTime         DateTime
  endTime          DateTime
  status           TrainingState @default(OPEN)
  trainingType     TrainingType  @default(WITHOUT_COACH)
  participants     User[]        @relation("TrainingParticipants")
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

enum Role {
  USER
  ORGANIZER
  ADMIN
}

enum MatchType {
  ONE_ON_ONE
  DOUBLES
}

enum MatchState {
  DRAFT
  PENDING
  CONFIRMED
  FINISHED
  CANCELLED
}

enum TrainingState {
  OPEN
  FULL
  CANCELLED
  DONE
}

enum TournamentType {
  SINGLE_ELIMINATION
  GROUPS_PLAYOFF
  LEAGUE
  BLITZ
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum SportType {
  TENNIS
  PADEL
}

enum RequestType {
  SINGLE_GAME
  TOURNAMENT
  TRAINING
}

enum RequestStatus {
  OPEN
  CLOSED
  CANCELLED
  DONE
}

enum ResponseStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum PaymentType {
  FREE
  HOST_PAYS
  LOSER_PAYS
  DIVIDED
  FIXED_PRICE
}

enum RatingType {
  RATED
  UNRATED
}

enum TrainingType {
  WITH_COACH
  WITHOUT_COACH
  TIEBREAK
  SPARRING
  TECHNIQUE
}

enum CourtSurface {
  HARD
  CLAY
  GRASS
  CARPET
}