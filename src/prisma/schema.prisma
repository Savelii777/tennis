generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AuthSource {
  WEB
  TELEGRAM_BOT
  MOBILE_APP
}

enum StoryStatus {
  pending
  approved
  rejected
}

enum MediaType {
  image
  video
}

model Story {
  id               Int         @id @default(autoincrement())
  userId           Int
  telegramFileId   String
  telegramFilePath String?
  type             MediaType
  status           StoryStatus @default(pending)
  createdAt        DateTime    @default(now())
  publishedAt      DateTime?
  updatedAt        DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model Country {
  id       Int    @id @default(autoincrement())
  name     String
  code     String @unique // ISO 3166-1 alpha-2
  flagUrl  String?
  cities   City[]
  users    User[]
  createdAt DateTime @default(now())
  
  @@index([code])
}


model City {
  id          Int     @id @default(autoincrement())
  name        String
  countryCode String
  country     Country @relation(fields: [countryCode], references: [code])
  population  Int
  lat         Float
  lng         Float
  timezone    String?
  users       User[]
  createdAt   DateTime @default(now())
  
  @@index([countryCode])
  @@index([population])
  @@index([name])
  @@unique([name, countryCode])
}

model Sport {
  id        Int    @id @default(autoincrement())
  title     String
  slug      String @unique
  emoji     String?
  users     User[]
  createdAt DateTime @default(now())
}

model User {
  id            Int      @id @default(autoincrement())
  telegramId    String   @unique
  username      String   @unique
  firstName     String
  lastName      String?
  isVerified    Boolean  @default(false)
  role          Role     @default(USER)
  countryCode String? 
  country     Country? @relation(fields: [countryCode], references: [code])
  cityId      Int?
  city        City?    @relation(fields: [cityId], references: [id])
  sportId     Int?
  sport       Sport?   @relation(fields: [sportId], references: [id])
  profile       UserProfile?
  matches       Match[]  @relation("PlayerMatches")
  createdMatches Match[] @relation("CreatorMatches")
  createdTrainings Training[] @relation("TrainingCreator")
  createdTrainingSessions TrainingSession[] @relation("TrainingSessionCreator")
  createdTournaments Tournament[] @relation("TournamentOrganizer")
  sentInvites Invite[] @relation("InviteSender")
  receivedInvites Invite[] @relation("InviteReceiver") 
  notifications Notification[]
  tournaments    Tournament[]
  createdRequests     GameRequest[]      @relation()
  requestParticipations GameRequest[]  @relation("RequestParticipants")
  requestResponses    RequestResponse[]
  trainingSessionParticipations TrainingSession[] @relation("TrainingParticipants")
  updatedAt     DateTime @updatedAt
  createdAt     DateTime @default(now())
  authSource    AuthSource   @default(WEB)
  lastLogin     DateTime?
  ballsBalance  Int          @default(0)
  casesOpened   Int          @default(0)
  telegramChatId BigInt?      // Для хранения chat_id пользователя
  
  // Новые обратные связи
  ballTransactions BallTransaction[]
  caseOpenings    CaseOpening[]
  stories         Story[]
}


model BallTransaction {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  amount        Int      // Положительное или отрицательное число
  description   String
  type          String   // "REWARD", "PURCHASE", "USAGE", "CASE_OPENING"
  createdAt     DateTime @default(now())
}

model Case {
  id            Int      @id @default(autoincrement())
  name          String
  description   String
  price         Int
  image         String?
  rewards       Json     // Массив возможных наград с вероятностями
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  openings      CaseOpening[]  // Добавьте эту строку - обратная связь с CaseOpening

}


model CaseOpening {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id])
  caseId        Int
  case          Case     @relation(fields: [caseId], references: [id])
  reward        Json     // Полученная награда
  createdAt     DateTime @default(now())
}

model Match {
  id            Int      @id @default(autoincrement())
  creator       User     @relation("CreatorMatches", fields: [creatorId], references: [id])
  creatorId     Int
  player1       User?    @relation("PlayerMatches", fields: [player1Id], references: [id])
  player1Id     Int?
  player2Id     Int?
  optionalId    Int?
  type          MatchType
  state         MatchState
  score         String?
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Training {
  id            Int      @id @default(autoincrement())
  creator       User     @relation("TrainingCreator", fields: [creatorId], references: [id])
  creatorId     Int
  location      String
  time          DateTime
  participantLimit Int
  description   String?
  state         TrainingState
  invites       Invite[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Tournament {
  id            Int      @id @default(autoincrement())
  title         String
  description   String?
  type          TournamentType
  status        String
  creator       User     @relation("TournamentOrganizer", fields: [creatorId], references: [id])
  creatorId     Int
  startDate     DateTime
  endDate       DateTime
  formatDetails Json?
  minPlayers    Int
  maxPlayers    Int
  currentPlayers Int
  isRanked      Boolean
  locationId    Int?
  locationName  String?
  players       User[]
  matches       TournamentMatch[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model TournamentMatch {
  id               Int       @id @default(autoincrement())
  tournament       Tournament @relation(fields: [tournamentId], references: [id])
  tournamentId     Int
  round            Int?
  group            String?
  playerAId        Int
  playerBId        Int?
  score            String?
  winnerId         Int?
  status           String
  court            String?
  scheduledAt      DateTime?
  confirmedBy      Int[]
  isThirdPlaceMatch Boolean @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
}

model Invite {
  id            Int      @id @default(autoincrement())
  match         Match?   @relation(fields: [matchId], references: [id])
  matchId       Int?
  training      Training? @relation(fields: [trainingId], references: [id])
  trainingId    Int?
  sender        User     @relation("InviteSender", fields: [senderId], references: [id])
  senderId      Int
  receiver      User     @relation("InviteReceiver", fields: [receiverId], references: [id])
  receiverId    Int
  status        InviteStatus
  createdAt     DateTime @default(now())
}

model Notification {
  id            Int      @id @default(autoincrement())
  user          User     @relation(fields: [userId], references: [id])
  userId        Int
  message       String
  createdAt     DateTime @default(now())
}

model UserProfile {
  id              Int      @id @default(autoincrement())
  user            User     @relation(fields: [userId], references: [id])
  userId          Int      @unique
  avatarUrl       String?
  city            String?
  countryCode     String?
  ntrpRating      Float?
  ratingPoints    Int      @default(0)
  matchesPlayed   Int      @default(0)
  matchWins       Int      @default(0)
  matchLosses     Int      @default(0)
  tournamentsPlayed Int    @default(0)
  tournamentsWon   Int     @default(0)
  lastActivity    DateTime?
  achievements    Json?
  isPublicProfile Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

    // ШАГ 1: Основные данные игрока
  preferredCourt      String?       // часто используемый корт
  dominantHand        String?       @default("RIGHT") // RIGHT, LEFT
  preferredPlayTime   String[]      // ['MORNING', 'DAY', 'EVENING', 'NIGHT']
  playsInTournaments  Boolean       @default(false)   // играет ли в турнирах
  weeklyPlayFrequency String?       // ONE, TWO_THREE, FOUR_PLUS
  
  // ШАГ 2: Стиль игры и уровень
  backhandType        String?       // ONE_HANDED, TWO_HANDED
  preferredSurface    String?       // HARD, CLAY, GRASS, CARPET
  playingStyle        String?       // UNIVERSAL, DEFENSIVE, AGGRESSIVE, NET_PLAYER, BASIC
  favoriteShot        String?       // SERVE, FOREHAND, BACKHAND, VOLLEY, SMASH
  racket              String?       // модель ракетки
  opponentPreference  String?       // ANY, MEN, WOMEN, SAME_LEVEL, STRONGER, WEAKER
  
  // Для рейтинга
  initialRatingPoints Int?          // начальные рейтинговые очки
  selfAssessedLevel   String?       // BEGINNER, AMATEUR, CONFIDENT, TOURNAMENT, SEMI_PRO
  profileStepOneCompleted Boolean @default(false)
  profileStepTwoCompleted Boolean @default(false)
}



model GameRequest {
  id               Int          @id @default(autoincrement())
  type             String       // Or use enum RequestType if defined
  title            String
  description      String?
  creatorId        Int
  creator          User         @relation(fields: [creatorId], references: [id])
  locationName     String?
  maxPlayers       Int
  currentPlayers   Int          @default(1)
  gameMode         String       // Or use enum MatchType
  dateTime         DateTime
  paymentType      String       // Or use enum PaymentType
  ratingType       String       // Or use enum RatingType  
  formatInfo       Json?
  status           String       @default("OPEN")
  participants     User[]       @relation("RequestParticipants")
  responses        RequestResponse[]
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

model RequestResponse {
  id              Int           @id @default(autoincrement())
  requestId       Int
  request         GameRequest   @relation(fields: [requestId], references: [id])
  userId          Int
  user            User          @relation(fields: [userId], references: [id])
  status          String        @default("PENDING")
  message         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([requestId, userId])
}

model TrainingSession {
  id               Int           @id @default(autoincrement())
  title            String
  description      String?
  creatorId        Int
  creator          User          @relation("TrainingSessionCreator", fields: [creatorId], references: [id])
  locationName     String?
  courtSurface     CourtSurface? @default(HARD)
  minLevel         Float?        // Минимальный NTRP уровень
  maxLevel         Float?        // Максимальный NTRP уровень
  maxSlots         Int
  currentSlots     Int           @default(1)
  paymentType      PaymentType   @default(DIVIDED)
  pricePerPerson   Float?
  dateTime         DateTime
  endTime          DateTime
  status           TrainingState @default(OPEN)
  trainingType     TrainingType  @default(WITHOUT_COACH)
  participants     User[]        @relation("TrainingParticipants")
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
}

enum Role {
  USER
  ORGANIZER
  ADMIN
}

enum MatchType {
  ONE_ON_ONE
  DOUBLES
}

enum MatchState {
  DRAFT
  PENDING
  CONFIRMED
  FINISHED
  CANCELLED
}

enum TrainingState {
  OPEN
  FULL
  CANCELLED
  DONE
}

enum TournamentType {
  SINGLE_ELIMINATION
  GROUPS_PLAYOFF
  LEAGUE
  BLITZ
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum SportType {
  TENNIS
  PADEL
}

enum RequestType {
  SINGLE_GAME
  TOURNAMENT
  TRAINING
}

enum RequestStatus {
  OPEN
  CLOSED
  CANCELLED
  DONE
}

enum ResponseStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum PaymentType {
  FREE
  HOST_PAYS
  LOSER_PAYS
  DIVIDED
  FIXED_PRICE
}

enum RatingType {
  RATED
  UNRATED
}

enum TrainingType {
  WITH_COACH
  WITHOUT_COACH
  TIEBREAK
  SPARRING
  TECHNIQUE
}

enum CourtSurface {
  HARD
  CLAY
  GRASS
  CARPET
}